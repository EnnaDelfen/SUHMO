# main - driver.cpp
main.domain_size=1000.00 1000.00 # physical dimensions of domain
main.problem_type=basic
main.maxTime=0.1
main.maxStep=1

# problem specific inputs
suhmo.H=500
suhmo.slope=0.02

# class AmrDriver.cpp
# misc
AmrDriver.verbosity=5
# mesh and refinement
AmrDriver.maxLevel=0
AmrDriver.ref_ratios=2 2 2
AmrDriver.block_factor=8
AmrDriver.max_box_size=32
AmrDriver.max_base_grid_size=32
AmrDriver.regrid_lbase=0
AmrDriver.regrid_interval=10000
AmrDriver.num_cells=16 16 # number of cells on coarsest domain
AmrDriver.domainLoIndex=0 0 # 2D
AmrDriver.is_periodic=0 0 # 2D
AmrDriver.tagCap=0
AmrDriver.fill_ratio=0.8
AmrDriver.nestingRadius=2
AmrDriver.tags_grow = 1  # amount to buffer tags
AmrDriver.tag_on_phi=true
AmrDriver.tagging_val=1.0
# Time Stepping params
AmrDriver.cfl=0.5
AmrDriver.initial_cfl=0.5
AmrDriver.max_dt_grow_factor=1.0
AmrDriver.fixed_dt=1.0 # over-ride dynamic dt computation 
AmrDriver.offsetTime=0.0
# Typically -1 for never, 0 for last step only, or integer interval (number of steps)
# Plot and output
AmrDriver.plot_interval=1
AmrDriver.plot_time_interval=0.0 # This is if we want to plot at a given time interval (rather than number of steps)
AmrDriver.plot_prefix = plot
AmrDriver.write_gradPhi=false
# Typically -1 for never, 0 for last step only, or interval
AmrDriver.check_interval=-1
AmrDriver.check_prefix=chk
AmrDriver.check_overwrite=false # if true, rewrite old checkpoints with new ones.
AmrDriver.check_exit=false # if true, exit immediately after writing a checkpoint

